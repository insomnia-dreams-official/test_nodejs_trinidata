# Тестовое задание для компании "Тринидата"

Есть высоконагруженный веб-сервис, который должен возвращать ветки деревьев, доставаемых из медленной БД. Для упрощения тестовой задачи будем считать, что мы можем прочитать возвращаемые данные из CSV-файлов с именами tree1.csv, tree2.csv, tree3.csv. В этих файлах содержится структура трех разных деревьев.
Каждый файл содержит столбцы id, name, parent, где parent – это id родителя элемента.

Запрос на ветвь имеет вид:
```
{
	tree: название файла с деревом,
	id: id элемента, с которого строится ветвь
}
```

Требуется, чтобы сервис порождал заданное количество воркеров wMax для обработки входящих HTTP-запросов, при первом обращении к сервису к какому-либо дереву:

1) Проверял, есть ли это дерево в кэше в памяти. Если есть, и дата модификации файла данного дерева не изменилась — отдавал ветку в виде многоуровнего JSON’а:
```
{
    id: ...,
    name: ...,
    children: [
        {
            id: ...,
            name: ...,
            children: null
        },
        ...
    ]
}
```


2) Если дата модификации дерева изменилась, либо кэша нет, то порождал воркер на создание данного кэша и отдавал ветку, вручную собрав ее из файла (со структурой как в п.1) и не дожидаясь окончания воркера перестройки кэша.

*Нужно учесть, что запросов может быть до 100 и более в секунду.*

---